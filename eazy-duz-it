#!/usr/bin/env python
import sys
from datetime import date
import subprocess
from subprocess import Popen, PIPE, STDOUT
import argparse
import os.path
import json
import shlex

MAX_ALLOWED_RELEASE_TAGS = 70

# TODO:
# * parse version from repo, perhaps by specifiying a file and line and regex of where to get the version
# * increment version automatically (optional)
# * provide json config in repo where all the details live
# * include the chef-data staging/production keys that should get updated
# * provide command: --pull-request (currently in progress)
# * provide command: --release (not started, but cuts a release)
#   * Need to:
#       * create local tag based on datetime format
#       * push tag to remote
#       * use the created tag as the hash against the release tag
# * provide command: --rollback (reverses process for speedy rollback)
# * provide command: --staging (automatically prompts to create a release if one doesn't exist)
# * provide command: --prod (fails if a staging was not yet updated and pre-release doesn't exist)
def pull_request(title):
#   # merge master template with contributing template
   global_template = load_template("GLOBAL.md").replace("{{SUMMARY}}", title + "\n")
   cont_json = load_json("eazy-duz-it.json")
   # generate exclusive repo contents
   tier = "- [ ] %s - Merge Checklist:\n" % cont_json["name"]
   # including checklist specific to this repo
   checklist = []
   if cont_json.get("requires_owner_review", False):
       checklist.append(checkbox("Team Reviewed: " + cont_json.get("owner", "")))
   checklist = checklist + [checkbox(c) for c in cont_json["contributing"]]

   checklist_template = "\n".join(checklist)
   merged_template = title + "\n\n" + global_template + tier + checklist_template

   # generate a PR against the merged templates
   # Note: the ugly dash is special syntax that reads from STDIN
   pr_cmd = shlex.split("hub pull-request -F -")
   p = Popen(pr_cmd, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
   cmd_stdout = p.communicate(input=merged_template)[0]
   link = cmd_stdout.decode()

   # assign resultant link to clipboard
   #setClipboardData(link)
   print link

def cut_release():
    # Generate tag format
    today = date.today()
    tag = today.strftime("%Y%m%d")
    # First check existing tags, to see if we need to increment.
    existing_tags = git_list_tags()
    for num in range(1, MAX_ALLOWED_RELEASE_TAGS):
        new_tag = tag + "." + str(num)
        if not new_tag in existing_tags:
            # Creates both local and remote tag
            git_tag(new_tag)

            # Note: the ugly dash is special syntax that reads from STDIN
            release_cmd = shlex.split("hub release create -p -f - new_tag")
            p = Popen(release_cmd, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
            cmd_stdout = p.communicate(input="Here is some fun stuff\nabc\nefg\nhij")[0]
            tag_link = cmd_stdout.decode()
            print tag_link
            break
            # Note: I don't think the step below is necessary, hub is smart enough to create a tag of any name you specifiy
            #     To create a git tag: git tag -a v0.1 -m "Only supports Pull-requests"
            # You only need this:
            # To create a release off that tag: hub release create -p -m "hi hooooo" "v0.1"

            # For testing purpose, delete tags like so:
            # git tag -d 12345
            # git push origin :refs/tags/12345

def checkbox(s):
    return "\t- [ ] " + s

def git_is_clean():
    clean_cmd = shlex.split("git status")
    p = Popen(clean_cmd, stdout=PIPE)
    if "Changes not staged for commit" in p.stdout.read():
        return False
    else:
        return True

def git_tag(tag):
    # create tag
    tag_cmd = shlex.split("git tag -a {0} -m Release on {0}".format(tag))
    p = Popen(tag_cmd, stdout=PIPE)
    print p.stdout.read()
    # push tag remote
    push_cmd = shlex.split("git push --follow-tags")
    p = Popen(push_cmd, stdout=PIPE)
    print p.stdout.read()

def git_list_tags():
    tag_cmd = shlex.split("git tag")
    p = Popen(tag_cmd, stdout=PIPE)
    result = p.stdout.read()
    tags = {t for t in result.split("\n") if len(t.strip()) > 0}
    return tags

def load_template(name):
    if os.path.isfile(name):
        with open(name, 'r') as f:
            lines = f.read()
            return lines
    return ""

def load_json(name):
    d = load_template(name)
    j = byteify(json.loads(d))
    return j

# Keeps json in simple ascii format
def byteify(input):
    if isinstance(input, dict):
        return {byteify(key):byteify(value) for key,value in input.iteritems()}
    elif isinstance(input, list):
        return [byteify(element) for element in input]
    elif isinstance(input, unicode):
        return input.encode('utf-8')
    else:
        return input

# Helper method for getting the clipboard's data
def getClipboardData():
    paste_cmd = shlex.split("pbpaste")
    p = subprocess.Popen(paste_cmd, stdout=subprocess.PIPE)
    retcode = p.wait()
    data = p.stdout.read()
    return data

# Helper method for setting the clipboard with data
def setClipboardData(data):
    copy_cmd = shlex.split("pbcopy")
    p = subprocess.Popen(copy_cmd, stdin=subprocess.PIPE)
    p.stdin.write(data)
    p.stdin.close()
    retcode = p.wait()

if __name__ == "__main__":
    # Don't do ANYTHING if git is not clean.
    if not git_is_clean():
        print "Aborting: branch not clean."
        #sys.exit(1) 

    parser = argparse.ArgumentParser(prog="eazy-duz-it")

    # pull-request arguments
    parser.add_argument("-pr", "--pull-request", dest="pr", help="generates a pull-request", action="store_true")
    parser.add_argument("-t", "--title", dest="title", help="title for your pull-request")

    # pre-release tag arguments
    parser.add_argument("-rt", "--release-tag", dest="rt", help="generates a release tag", action="store_true")

    args = parser.parse_args()

    # Creates a pull-request
    if args.pr:
        if not args.title:
            print "You need a title."
        pull_request(args.title)
    elif args.rt:
        cut_release() # does nothing yet
